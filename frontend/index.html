<!DOCTYPE html>
<html>
<head>
    <title>Trail Running Visualization</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.1/gpx.min.js"></script>
    <style>
        /* Layout: navbar + map filling rest of viewport */
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        .navbar {
            height: 56px;
            background: linear-gradient(90deg,#243447,#2c3e50);
            color: #fff;
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            z-index: 1000;
            gap: 12px;
        }
        .navbar .title {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        .navbar .actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .navbar select, .navbar button {
            font-size: 0.95rem;
            color: #2b3942;
            background: #fff;
            border: 0;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            outline: none;
            transition: transform .08s ease, box-shadow .12s ease;
        }
        .navbar select {
            min-width: 170px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 38px; /* espaço para caret */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24'%3E%3Cpath fill='%232b3942' d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            cursor: pointer;
        }
        .navbar select:focus, .navbar button:focus {
            box-shadow: 0 6px 18px rgba(52,152,219,0.18);
            transform: translateY(-1px);
        }
        .navbar button {
            background: linear-gradient(180deg,#3498db,#2b85d6);
            color: #fff;
            padding: 8px 14px;
            border-radius: 8px;
        }
        .navbar button:hover {
            transform: translateY(-2px);
        }

        #map {
            flex: 1; /* preenche o espaço restante da viewport */
            min-height: 0; /* evita overflow em alguns navegadores */
        }

        /* pequenos ajustes para popups/ícones GPX se necessário */
        .gpx-info { font-size: 0.9rem; }
    </style>
</head>
<body>
    <p>Hello World!</p>
    <nav class="navbar">
        <div class="title">Trail Run — Simulation View (WIP)</div>
        <div class="actions">
            <!-- Seletor de corrida (placeholder para suporte futuro do backend) -->
            <select id="race-select" title="Pick a race" style="margin-right:8px;">
                <option value="">Pick race</option>
                <!-- futuras corridas podem ser adicionadas aqui dinamicamente -->
            </select>

            <!-- Seletor de corredor + zoom -->
            <select id="runner-select" title="Pick a runner" style="min-width:160px; margin-right:8px;">
                <option value="">Pick runner</option>
            </select>
            <button id="zoom-runner" title="Zoom to selected runner">Zoom</button>
            <button id="zoom-fit" title="Fit map to route" style="margin-left:8px;">Fit Route</button>
        </div>
    </nav>

    <div id="map"></div>

    <script>
        // Criar o mapa Leaflet
        const map = L.map('map').setView([0, 0], 13); // Vista inicial (será atualizada)

        // Adicionar OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Carregar o ficheiro GPX e centrar o mapa
        const gpxFile = './trail_route.gpx'; // O GPX deve estar acessível via HTTP no servidor do frontend
        const gpxLayer = new L.GPX(gpxFile, {
            async: true, // Carrega o ficheiro GPX de forma assíncrona
            marker_options: {
                startIconUrl: "./start.png",
                endIconUrl: "./finish.png",
            }
        }).on('loaded', function(e) {
            // Ajusta o mapa aos limites da rota GPX
            map.fitBounds(e.target.getBounds());
        }).addTo(map);

        // Botão de ajuste: recentralizar para os limites do GPX se disponível
        document.getElementById('zoom-fit').addEventListener('click', () => {
            try {
                const bounds = gpxLayer.getBounds && gpxLayer.getBounds();
                if (bounds && bounds.isValid && bounds.isValid()) {
                    map.fitBounds(bounds);
                } else if (bounds) {
                    map.fitBounds(bounds);
                } else {
                    console.warn('GPX bounds not available yet.');
                }
            } catch (err) {
                console.error('Unable to fit map to route:', err);
            }
        });

        // Dicionário para armazenar marcadores de cada atleta
        const athleteMarkers = {};

        const maleIcon = L.icon({
            iconUrl: "male.png",
            iconSize: [28, 65],
            iconAnchor: [12, 64],
            popupAnchor: [-3, -46]
        });

        const femaleIcon = L.icon({
            iconUrl: "female.png",
            iconSize: [28, 65],
            iconAnchor: [12, 64],
            popupAnchor: [-3, -46]
        });

        // Selecionar runners e zoom
        const runnerSelect = document.getElementById('runner-select');
        const zoomRunnerBtn = document.getElementById('zoom-runner');

        function addRunnerOption(name) {
            // Para evitar duplicados
            if (![...runnerSelect.options].some(o => o.value === name)) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                runnerSelect.appendChild(opt);
            }
        }

        function zoomToRunner(name, zoomLevel = 16) {
            const marker = athleteMarkers[name];
            if (!marker) {
                console.warn('Runner not found on map:', name);
                return;
            }
            const latlng = marker.getLatLng();
            map.setView(latlng, zoomLevel, {animate: true});
            marker.openPopup && marker.openPopup();
        }

        // Comportamento do botão de zoom
        zoomRunnerBtn.addEventListener('click', () => {
            const selected = runnerSelect.value;
            if (selected) zoomToRunner(selected);
        });

        // Opcional: auto-zoom ao selecionar um corredor no dropdown
        runnerSelect.addEventListener('change', (e) => {
            const name = e.target.value;
            if (name) zoomToRunner(name);
        });

        // Função para ligar ao WebSocket com reconexão automática
        function connectWebSocket() {
            // Cria a ligação WebSocket usando o hostname atual
            const socket = new WebSocket("ws://" + window.location.hostname + ":8000/ws");

            // Evento ao receber mensagem do backend
            socket.onmessage = function (event) {
                try {
                    const data = JSON.parse(event.data);

                    // Validação dos dados recebidos
                    if (!data.athlete || !data.location || !data.location.latitude || !data.location.longitude || !data.gender) {
                        console.warn("Mensagem WebSocket ignorada: formato inválido", data);
                        return;
                    }

                    // Extrai dados do atleta
                    const athlete = data.athlete;
                    const gender = data.gender;
                    const lat = data.location.latitude;
                    const lon = data.location.longitude;

                    // Escolhe o ícone com base no género
                    const icon = gender === "male" ? maleIcon : femaleIcon;

                    // Atualiza o marcador se já existir, senão cria um novo
                    if (athlete in athleteMarkers) {
                        const m = athleteMarkers[athlete];
                        m.setLatLng([lat, lon]);
                        // If currently selected runner, pan to their new position
                        if (runnerSelect.value === athlete) {
                            map.panTo(m.getLatLng(), {animate: true});
                        }
                    } else {
                        // Cria novo marcador para o atleta
                        const marker = L.marker([lat, lon], {icon: icon})
                            .addTo(map)
                            .bindPopup(`<b>${athlete}</b>`);
                        // clicking a marker selects it in the dropdown and zooms
                        marker.on('click', () => {
                            runnerSelect.value = athlete;
                            zoomToRunner(athlete);
                        });
                        athleteMarkers[athlete] = marker;
                        addRunnerOption(athlete);
                    }
                } catch (e) {
                    // Erro ao processar mensagem recebida
                    console.error("Erro ao processar mensagem WebSocket:", e);
                }
            };

            // Evento ao perder ligação WebSocket
            socket.onclose = function () {
                console.warn("Ligação WebSocket perdida. A tentar reconectar...");
                setTimeout(connectWebSocket, 2000);
            };

            // Evento de erro na ligação WebSocket
            socket.onerror = function (e) {
                console.error("Erro na ligação WebSocket:", e);
                socket.close();
            };
        }
        // Inicia a ligação WebSocket
        connectWebSocket();
    </script>
</body>
</html>